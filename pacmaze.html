<!-- 
	Pacmaze. This is a pacman-like 3d game based on webgl, html and javascript.
    Copyright (C) <2015>  <Lappas Dionysis dio@freelabs.net>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

 -->


<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="description" content="Pacmaze is a pacman 3d game based on web technologies">
	<meta name="keywords" content="pacmaze, webgl">
	<meta name="author" content="Lappas Dionysis">
	<title>Pacmaze</title>
	<!-- external libraries for matrix calculations and maintenance -->
	<script type="text/javascript" src="./sandbox_files/glMatrix-0.9.5.min.js"></script>
	<script type="text/javascript" src="./sandbox_files/webgl-utils.js"></script>

	<!-- Code for the vertex shader-->
	<script id="shader-vs" type="x-shader/x-vertex">
	//attributes for the vertex shader (different for every thread/core that will execute a copy of this)
	    attribute vec3 aVertexPosition;
	    attribute vec4 aVertexColor;
	    attribute vec4 aNormal;
	    uniform mat4 uNormalMatrix;		//Transformation matrix of the normal
	    uniform vec3 uLightColor;		//Light color
	    uniform vec3 uLightPosition;	//Position of the light source (in the world coordinate system)
	    uniform vec3 uLightDirection;
	    uniform vec3 uAmbientLight;		//Ambient light color
	    uniform int uDrawCustomColor;

		//ModelView and Projection Matrices
	    uniform mat4 uMVMatrix;
	    uniform mat4 uPMatrix;

		//Variable to be forwarded to the corresponding thread of the fragment shader
	    varying vec4 vColor;

		//main function of the vertex shader
		//this code will be copied to many shader cores/threads and executed with the associated
		//data for every vertex (matrices, color, etc)
	    void main(void) {
	    	vec4 color = aVertexColor;

		    if (uDrawCustomColor == 1){
		    	//yellow
		    	 color = vec4(1.0, 1.0, 0.0, 1.0); 
		    }else if (uDrawCustomColor == 2){
		    	//red
		    	 color = vec4(1.0, 0.0, 0.0, 1.0); 
		    }else if (uDrawCustomColor == 3){
		    	//pink
		    	 color = vec4(1.0, 0.753, 0.796, 1.0); 
		    }else if (uDrawCustomColor == 4){
		    	//cyan
		    	 color = vec4(0.0, 1.0, 1.0, 1.0); 
		    }else if (uDrawCustomColor == 5){
		    	//orange
		    	 color = vec4(1.0, 0.647, 0.0, 1.0); 
		    }else if (uDrawCustomColor == 6){
		    	//orange
		    	 color = vec4(0.0, 0.0, 1.0, 1.0); 
		    }
		//Each vertex is multiplied with the ModelView and Projection matrices and created a fragment
		    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		//Recalculate normal with normal matrix and make its length 1.0
			vec3 normal = normalize(vec3(uNormalMatrix * aNormal));
		//Calculate the world coordinate of the vertex
			vec4 newVertexPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		//Calculate the light direction and make it 1.0 in length
			vec3 lightDirection = normalize(uLightPosition - vec3(newVertexPosition));
  		//Dot product of the light direction and the orientation of a surface (the normal)
 			float nDotL = max(dot(lightDirection, normal), 0.0);
  		//Calculate the color due to diffuse reflection, color is forwarded to the fragment shader
  			vec3 diffuse = uLightColor * color.rgb * nDotL;
		//Calculate the color due to ambient reflection
			vec3 ambient = uAmbientLight * color.rgb;
		//Add surface colors due to diffuse and ambient reflection
			vColor = vec4(diffuse + ambient, color.a);
	    }

	</script>

	<!-- Code for the fragment shader-->
	<script id="shader-fs" type="x-shader/x-fragment">
	    //necessary code for compatibility
		precision mediump float;

		//Variable coming from the vertex shader
	    varying vec4 vColor;

	    void main(void) {
		//the fragment gets its color value.
		//in the fragment shader many advanced shading algorithms can be implemented (Phong etc..)
	        gl_FragColor = vColor;
	    }
	</script>


	<!-- Javascript code for the main functionality of the WebGL application-->
	<script type="text/javascript">
		//ModelView and Projection matrices
		//mat4 comes from the external library
   		var mvMatrix = mat4.create();
   		var mvMatrixStack = [];
   		var pMatrix = mat4.create();
   		var normalMatrix = mat4.create();
   		var sphereLighting = false;
   		//This var is used to encode 6 olor values
   		//[0]->Off, [1]->yellow, [2]->red, [3]->pink, [4]->cyan, [5]->orange, [6]->blue
   		var drawCustomColor = 0;

		//the variable that will accommodate the WebGL context
		//every call to the state machine will be done through this variable
	    var gl;

	    //The matrix stack operation are implemented below to handle local transformations
	
		//Push Matrix Operation
	    function mvPushMatrix() {
	        var copy = mat4.create();
	        mat4.set(mvMatrix, copy);
	        mvMatrixStack.push(copy);
	    }

		//Pop Matrix Operation
	    function mvPopMatrix() {
	        if (mvMatrixStack.length == 0) {
	            throw "Invalid popMatrix!";
	        }
	        mvMatrix = mvMatrixStack.pop();
	    }

		//Sets + Updates matrix uniforms
	    function setMatrixUniforms() {
	    	gl.uniform1i(shaderProgram.uDrawCustomColor, drawCustomColor);

	        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
	        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

	       	//Set the light color (white)
 			gl.uniform3f(shaderProgram.uLightColor, 0.5, 0.5, 0.5);
  			//Set the light direction (in the world coordinate)
  			var lightDirection = [2.3, 4.0, 3.5];

 			gl.uniform3fv(shaderProgram.uLightDirection, new Float32Array(lightDirection));
 			gl.uniform3f(shaderProgram.uAmbientLight, 0.5, 0.1, 0.4);

			//Pass the transformation matrix for normal to u_NormalMatrix
 			gl.uniformMatrix4fv(shaderProgram.uNormalMatrix, false,  new Float32Array(normalMatrix));

 			//Set the position of the light source (in the world coordinate)
			gl.uniform3f(shaderProgram.uLightPosition, 8.0, 7.0, -10.0);
	    }


	    //Rotation function helper
		function degToRad(degrees) {
 	       return degrees * Math.PI / 180;
  		 }


		//Initialize WebGL
	    function initGL(canvas) {
	        try {
			//get a webgl context
	            gl = canvas.getContext("webgl");
				//assign a viewport width and height based on the HTML canvas element properties
				//(check last lines of code)
	            gl.viewportWidth = canvas.width;
	            gl.viewportHeight = canvas.height;
				//any error is handled here
				//all errors are visible in the console (F12 in Google chrome)
	        } catch (e) {
	        }
	        if (!gl) {
	            alert("Could not initialise WebGL, sorry :-(");
	        }
	    }


		//Find and compile shaders (vertex + fragment shader)
	    function getShader(gl, id) {
		//gets the shader scripts (vertex + fragment)
	        var shaderScript = document.getElementById(id);
	        if (!shaderScript) {
	            return null;
	        }

	        var str = "";
	        var k = shaderScript.firstChild;
	        while (k) {
	            if (k.nodeType == 3) {
	                str += k.textContent;
	            }
	            k = k.nextSibling;
	        }

	        var shader;
			//create shaders
	        if (shaderScript.type == "x-shader/x-fragment") {
	            shader = gl.createShader(gl.FRAGMENT_SHADER);
	        } else if (shaderScript.type == "x-shader/x-vertex") {
	            shader = gl.createShader(gl.VERTEX_SHADER);
	        } else {
	            return null;
	        }

			//ask WebGL to compile shaders
			//we check for errors here too
			//all errors are visible in the console (F12 in Google chrome)
	        gl.shaderSource(shader, str);
	        gl.compileShader(shader);

	        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	            alert(gl.getShaderInfoLog(shader));
	            return null;
	        }

	        return shader;
	    }

		
	    var shaderProgram;

		//Creates a program from a vertex + fragment shader pair
	    function initShaders() {
	        var fragmentShader = getShader(gl, "shader-fs");
	        var vertexShader = getShader(gl, "shader-vs");

	        shaderProgram = gl.createProgram();
	        gl.attachShader(shaderProgram, vertexShader);
	        gl.attachShader(shaderProgram, fragmentShader);
			//link the compiled binaries
	        gl.linkProgram(shaderProgram);

			//check for errors, again
	        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
	            alert("Could not initialise shaders");
	        }

			//activate current program
			//this sandbox has only on shader pair
			//we can have as many as we wish in more complex applications
	        gl.useProgram(shaderProgram);

			//Update attributes for the vertex shader
			//attributes are accessible only from the vertex shader
			//if we want accessible data from a fragment shader we can use uniform variables,
			//or varyings that will be forwarded from the vertex shader to the fragment shader
			
			//Vertex position data
	        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
	        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

			//Vertex color data
	        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
	        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

	        //Vertex normal data
	        shaderProgram.aNormal = gl.getAttribLocation(shaderProgram, 'aNormal');
	        gl.enableVertexAttribArray(shaderProgram.aNormal);


			//Update uniform variables
			//this variables can be accessed from both the vertex and fragment shader
			//Get the storage locations 
	        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
	        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
	        shaderProgram.uLightColor = gl.getUniformLocation(shaderProgram, 'uLightColor');
  			shaderProgram.uLightDirection = gl.getUniformLocation(shaderProgram, 'uLightDirection');
  			shaderProgram.uAmbientLight = gl.getUniformLocation(shaderProgram, 'uAmbientLight');
  			shaderProgram.uNormalMatrix = gl.getUniformLocation(shaderProgram, 'uNormalMatrix');  	
  			shaderProgram.uLightPosition = gl.getUniformLocation(shaderProgram, 'uLightPosition');	 
  			shaderProgram.uDrawCustomColor = gl.getUniformLocation(shaderProgram, 'uDrawCustomColor');	 
	    }

		//Vertex, Index and Color Data
  		var cubeVertexPositionBuffer; //contains coordinates
    	var cubeVertexColorBuffer; //contains color per vertex
    	var cubeVertexIndexBuffer; //contains indices for chains of vertices to draw triangles/other geometry
    	var cubeVertexNormalBuffer;//cube normals
    	var spherePositionsBuffer; //contains sphere coordinates
    	var sphereIndicesBuffer;   //contains indices for sphere 
    	var sphereVertexNormalBuffer;//sphere normals

		//Initialize VBOs, IBOs and color
	    function initBuffers() {
	    	 //Create a cube
 			 //   v6----- v5
 			 //  /|      /|
			 // v1------v0|
 			 // | |     | |
 			 // | |v7---|-|v4
 			 // |/      |/
 			 // v2------v3
			//Vertex Buffer Object
	        cubeVertexPositionBuffer = gl.createBuffer();
			//Bind buffer to ARRAY_BUFFER
	        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
	        vertices = [
	            //Front face
	            -1.0, -1.0,  1.0,
	             1.0, -1.0,  1.0,
	             1.0,  1.0,  1.0,
	            -1.0,  1.0,  1.0,

	            //Back face
	            -1.0, -1.0, -1.0,
	            -1.0,  1.0, -1.0,
	             1.0,  1.0, -1.0,
	             1.0, -1.0, -1.0,

	            //Top face
	            -1.0,  1.0, -1.0,
	            -1.0,  1.0,  1.0,
	             1.0,  1.0,  1.0,
	             1.0,  1.0, -1.0,

	            //Bottom face
	            -1.0, -1.0, -1.0,
	             1.0, -1.0, -1.0,
	             1.0, -1.0,  1.0,
	            -1.0, -1.0,  1.0,

	            //Right face
	             1.0, -1.0, -1.0,
	             1.0,  1.0, -1.0,
	             1.0,  1.0,  1.0,
	             1.0, -1.0,  1.0,

	            //Left face
	            -1.0, -1.0, -1.0,
	            -1.0, -1.0,  1.0,
	            -1.0,  1.0,  1.0,
	            -1.0,  1.0, -1.0
	        ];
	        //every item has 3 coordinates (x,y,z)
	        cubeVertexPositionBuffer.itemSize = 3;
			//we have 24 vertices
	        cubeVertexPositionBuffer.numItems = 24;
	        //Bind buffer to ARRAY_BUFFER
	        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
	        //Write data to buffer
	        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	        //Assign the buffer object bound to gl.ARRAY_BUFFER to the attribute variable shaderProgram.vertexPositionAttribute
	        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

	        //gl.bindBuffer(gl.ARRAY_BUFFER, null);

			//Color
	        cubeVertexColorBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
	        colors = [
	            [1.0, 0.0, 0.0, 1.0], //Front face
	            [1.0, 1.0, 0.0, 1.0], //Back face
	            [0.0, 1.0, 0.0, 1.0], //Top face
	            [1.0, 1.0, 0.5, 1.0], //Bottom face
	            [1.0, 0.0, 1.0, 1.0], //Right face
	            [0.0, 0.0, 1.0, 1.0]  //Left face
	        ];
	        var unpackedColors = [];
	        for (var i in colors) {
	            var color = colors[i];
				//assign colors for each vertex of each face based on the packed representation above
	            for (var j=0; j < 4; j++) {
	                unpackedColors = unpackedColors.concat(color);
	            }
	        }
	        //every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
	        cubeVertexColorBuffer.itemSize = 4;
			//24 color values (we have 24 vertices to color...)
	        cubeVertexColorBuffer.numItems = 24;
	        //Bind the buffer for the cube colors to ARRAY_BUFFER
       		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
       		//Write data to buffer
       		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
       		//Assign the buffer object bound to gl.ARRAY_BUFFER to the attribute variable shaderProgram.vertexColorAttribute
       	 	gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        
	        //gl.bindBuffer(gl.ARRAY_BUFFER, null);

	        //Normal Vectors
	        var normals = [    //Normal
				0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  //v0-v1-v2-v3 front
				1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  //v0-v3-v4-v5 right
				0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  //v0-v5-v6-v1 up
			   -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  //v1-v6-v7-v2 left
				0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  //v7-v4-v3-v2 down
				0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   //v4-v7-v6-v5 back
			];

	        //Normal buffer object
	        cubeVertexNormalBuffer = gl.createBuffer();
	        //every vertex has 3 normal vectors
	        cubeVertexNormalBuffer.itemSize = 3;
			//every face has 4 verices, a total fo 24 normals
	        cubeVertexNormalBuffer.numItems = 24;
	        //Bind the buffer for the cube normals to ARRAY_BUFFER
       		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
       		//Write data to buffer
       		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
       		//Assign the buffer object bound to gl.ARRAY_BUFFER to the attribute variable shaderProgram.
       	 	gl.vertexAttribPointer(shaderProgram.aNormal, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);


			//Index Buffer Object
			//it joins sets of vertices into faces
	        cubeVertexIndexBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
	        var cubeVertexIndices = [
			//this numbers are positions in the VBO array above
	            0, 1, 2,      0, 2, 3,    //Front face
	            4, 5, 6,      4, 6, 7,    //Back face
	            8, 9, 10,     8, 10, 11,  //Top face
	            12, 13, 14,   12, 14, 15, //Bottom face
	            16, 17, 18,   16, 18, 19, //Right face
	            20, 21, 22,   20, 22, 23  //Left face
	        ];
	        //we have one item - the cube
			cubeVertexIndexBuffer.itemSize = 1;
			//we have 36 indices (6 faces, every face has 2 triangles, each triangle 3 vertices: 2x3x6=36)
	        cubeVertexIndexBuffer.numItems = 36;
	        //Bind the buffer for vertex indices to ELEMENT_ARRAY_BUFFER
       		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
       		//Write data to buffer
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);

	    	//gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

	    }


		//Helper Variables
	    var rCube = 0;
		var xTrans = 0.0;
		var yTrans = 0.0;
		var xzTrans = 0.0;
		var swinging = 0.01;
		var movDirection = true;
		//array for keeping pressed keys
		var currentlyPressedKeys = {};

		//Keyboard handler
		//do not touch :) 
	    function handleKeyDown(event) {
	        currentlyPressedKeys[event.keyCode] = true;

	        if (String.fromCharCode(event.keyCode) == "P") {
	        	//Enable Panoramic game camera
	            game.gameCamera = false; 
	        } else if (String.fromCharCode(event.keyCode) == "T"){
	        	//Enable Tracking game camera
	        	game.gameCamera = true;
	        }
	    }

		//Keyboard handler
		//do not touch :) 
	    function handleKeyUp(event) {
	        currentlyPressedKeys[event.keyCode] = false;
	    }

		//Key pressed callback
		//37-40 are the codes for the arrow keys
		//xTrans + yTrans are used in the ModelView matrix for local transformation of the cube
	    function handleKeys() {
	    	//checkPossibleMoves(pacman);
	    	if (game.ignoreKeys == false){
		   		if (currentlyPressedKeys[37]) {
		            //Left cursor key
		            pacman.nextDirection = 10;
		           //determineMove(pacman);
		        }
		        if (currentlyPressedKeys[39]) {
		            //Right cursor key
		            pacman.nextDirection = 20;
		            //determineMove(pacman);
		        }
		        if (currentlyPressedKeys[38]) {
		            //Up cursor key
		            pacman.nextDirection = 1;
		           //determineMove(pacman);
		        }
		        if (currentlyPressedKeys[40]) {
		            //Down cursor key
		            pacman.nextDirection = 2;
		            //determineMove(pacman);		        
		        }
	    	}

	    }

		//x: maze blocks, p: pellets, U: power Pellets
    	var x = 'x';
    	var p = 'p';
    	var U = 'U';
    	var level1_design = [
	    	[x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x],
	    	[x,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,p,x],
	    	[x,p,x,x,x,x,x,x,p,x,p,x,x,x,x,x,x,p,x], 
	    	[x,p,p,p,p,x,p,p,p,x,p,p,p,x,p,p,p,p,x], 
	    	[x,x,p,x,p,x,p,x,x,x,x,x,p,x,p,x,p,x,x], 
	    	[x,p,p,x,p,p,p,p,p,p,p,p,p,p,p,x,p,p,x], 
	    	[x,U,x,x,p,x,x,x,p,x,p,x,x,x,p,x,x,U,x], 
	    	[x,p,p,p,p,p,p,p,p,x,p,p,p,p,p,p,p,p,x], 
	    	[x,p,x,x,p,x,p,x,x,x,x,x,p,x,p,x,x,p,x], 
	    	[x,p,p,p,p,x,p,p,p,p,p,p,p,x,p,p,p,p,x], 
	    	[x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x]
        ];

        var level2_design = [
		[x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x],
		[x,U,p,p,p,p,p,x,x,x,p,p,p,p,p,p,p,x,x,x,p,p,p,p,p,p,p,p,U,x],
		[x,p,x,x,x,x,p,x,p,p,p,x,p,x,x,x,p,p,p,p,p,x,x,x,p,x,x,x,p,x],
		[x,p,x,p,p,p,p,x,p,x,x,x,p,x,p,p,p,p,x,x,x,x,p,p,p,p,p,p,p,x],
		[x,p,x,p,x,x,p,x,p,x,p,p,p,x,p,x,x,p,p,p,p,p,p,p,x,p,x,p,x,x],
		[x,p,x,p,x,x,p,x,p,p,p,x,p,p,p,x,x,p,x,x,p,x,p,x,x,p,x,p,p,x],
		[x,p,p,p,p,p,p,p,x,p,x,x,p,x,x,p,p,p,x,p,p,x,p,x,x,p,x,x,p,x],
		[x,p,x,x,x,p,x,p,x,p,p,p,p,p,p,p,x,p,x,p,x,x,p,x,p,p,p,p,p,x],
		[x,p,x,x,x,p,x,p,p,p,x,x,x,p,x,p,x,p,p,p,p,p,p,p,p,x,p,x,p,x],
		[x,p,p,p,p,p,x,p,x,p,p,p,p,p,x,p,p,x,x,x,p,x,x,x,p,x,p,p,p,x],
		[x,x,p,x,p,x,x,p,x,p,x,p,x,p,p,x,p,p,p,x,p,p,p,p,p,x,x,x,p,x],
		[x,x,p,x,p,p,p,p,p,p,x,p,x,x,p,x,p,x,p,x,p,x,x,x,p,p,p,p,p,x],
		[x,x,p,x,p,x,p,x,p,p,p,p,p,x,p,x,p,x,p,x,p,p,p,p,x,x,x,x,p,x],
		[x,x,p,x,p,x,p,p,x,x,p,x,p,p,p,p,p,x,p,x,p,x,x,x,p,p,p,p,p,x],
		[x,p,p,p,p,x,x,p,x,x,p,x,p,x,x,p,x,p,p,p,p,p,p,p,p,x,x,x,x,x],
		[x,p,x,x,p,x,p,p,p,x,p,x,p,x,p,p,x,p,x,p,x,x,p,p,p,p,p,p,p,x],
		[x,p,x,x,p,x,p,x,p,x,p,p,p,x,p,x,x,p,x,p,x,x,x,x,p,x,x,x,p,x],
		[x,U,p,p,p,p,p,x,p,p,p,x,x,x,p,p,p,p,x,p,p,p,p,p,p,p,p,p,U,x],
		[x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x]
        ];


        function mazeTile(aType, num, indx, indz) {
        	this.type = aType; 	//Types are x:maze, p:pellet, U:powerPellet
			this.vertices = []; //Vertices of cube's bottom face [x,z] pairs
			this.num = num;
			this.mCenter = [];	//The center of mass
			this.indX = indx;	//Index on the x-axis
			this.indZ = indz;	//Index on the z-axis
			//4xi array, i=(0, 1) if move is allowed or not
			//First index codes the direction of movement. If movement
			//to that direction is allowed, store reference to tile.
			//[1]> move up, [2]-> move down, [10]-> move left, [20]-> move right
			//E.g. If elem[0][1] !== undefined -> move up allowed, elem[0][1] 
			//holds reference to that tile. 
			this.moves = [];
        }

        function createLevel(levelDesign){	
        	var width = levelDesign[0].length;
        	var height = levelDesign.length;
        	var createdLevel = [];
        	var tmpTileVec = [];

        	for (var i=0; i<height; i++){        		
        		for (var j=0; j<width; j++){
        			var tileNum = i*width + j;
        			tmpTileVec.push(new mazeTile(levelDesign[i][j], tileNum, i, j));
        		}
        		createdLevel.push(tmpTileVec);
        		tmpTileVec = [];
        	}
        	return createdLevel;
        }

        function initLevelMoves(levelDesign, tilesArray) {
        	var width = levelDesign[0].length;
        	var height = levelDesign.length;
			for (var i=0; i<height; i++){        		
        		for (var j=0; j<width; j++){
        			//Check if there is up tile	
        			if (i+1 < height){
        				var upTile = tilesArray[i+1][j];
        				//Check if move is allowed
        				if (upTile.type == 'p' || upTile.type == 'U' ){
        					//Store tile
        					tilesArray[i][j].moves[1] = upTile;
        				}
        			}
        			//Check if there is down tile
        			if (0 <= i-1){
        				var downTile = tilesArray[i-1][j];
        				//Check if move is allowed
        				if (downTile.type == 'p' || downTile.type == 'U' ){
        					//Store tile
        					tilesArray[i][j].moves[2] = downTile;
        				}
        			}
					//Check if there is left tile
        			if (0 <= j-1){
        				var leftTile = tilesArray[i][j-1];
        				//Check if move is allowed
        				if (leftTile.type == 'p' || leftTile.type == 'U' ){
        					//Store tile
        					tilesArray[i][j].moves[10] = leftTile;
        				}
        			}
   					//Check if there is right tile
        			if (j+1 < width){
        				var rightTile = tilesArray[i][j+1];
        				//Check if move is allowed
        				if (rightTile.type == 'p' || rightTile.type == 'U' ){
        					//Store tile
        					tilesArray[i][j].moves[20] = rightTile;
        				}
        			}

        			//Store pellets
        			if ( tilesArray[i][j].type == 'p' || tilesArray[i][j].type == 'U'){
        				maze.pellets.push(tilesArray[i][j]);
        				maze.totalPellets++;
        			}     			
        		}
        	}
        }

        var maze = {
        	//The current maze level. 2D array created based on
        	//levelDesign. Extra members: level[][].moves[], level[][].num
			level: 		[],	
			height: 	0,	//Height of current maze level
			width: 		0,	//Width of current maze level
			speed: 		0.07,	//Distance to move on every move
			pellets: 	[],	//Pellet tiles
			totalPellets: 0, //Total maze pellets at any time
			init: function(level, height, width){
				this.level 	= level;
				this.height = height;
				this.width 	= width;
				this.pellets = [];
				this.totalPellets = 0;
			}
		};

		var tileMold = {
			baseEdge: 	2.0, //Based on cube's initial coords(-1, 1)
			scale: 		1.0, //Scale factor to apply		
			scaleX: 	0.0, //Scale factor for x-axis
			scaleY: 	0.4, //Scale factor for y-axis
			scaleZ: 	0.0, //Scale factor for z-axis
			edge: 		0.0, //The edge of each tile
			transY:    -5.0, //Translation of each tile on y-axis
			zDirection: -1.0, //Tile propagation direction on z-axis
			//Initialized parameters
			init: function(){
				this.scaleX = this.scale;
				this.scaleZ = this.scale;
				this.edge = this.baseEdge * this.scale;
			} 	
		};	    

		var game = {
			normalSpeed: 	0.07,	//Normal game speed
			slowGhostSpeed:	0.02,	//Power pellet mode, slow speed for ghosts
			defGhostSpeed: 	0.065,	//The default speed at which ghosts move
			curGhostSpeed: 	0.065,	//The current speed at which ghosts move
 			moveDirections: [1, 2, 10, 20],	//Available move directions
			gameOver: 		false,	//Game Over
			lives: 			3,		//pacman's current lives
			lostLife: 		false,	//pacman lost one life
			ignoreKeys: 	false, 	//Ignore or not arrow keystrokes	
			gameCamera: 	true,	//True is tracking camera, false Panoramic
			powerMode: 		false,	//For power pellets
			levelUp: 		false,	//For next level
			powerModeDur:	6000, 	//How much time pacman is in power mode, in ms
			score: 			-50,	//The game score, 50 points for earch pellet
			ghostsBusted: 	[],		//Ghosts that were busted 
			levelNum: 		1, 		//The current game level (e.g. 1, 2 etc)
			init: function(){
				this.ignoreKeys = false; 
				this.gameOver 	= false;
				this.lostLife	= false;
				this.gameCamera = true; 
				this.powerMode	= false;
				this.levelUp	= false;
				this.lives 		= 3;
				this.ghostSpeed = 0.065;
				this.powerModeDur = 6000;
				this.score 		= -50;
				this.ghostsBusted = []; 
			}
		}

		function moveGhosts(ghost){
			var move;

			if (ghost.curDirection == 0){
			//Make a random move from available moves
			move = game.moveDirections[Math.floor(Math.random()*game.moveDirections.length)]; 
			}else{
				move = ghost.curDirection;
			}

			return move;
		}

		function checkGameplay(){
			//Check if game is over
			if (game.gameOver == false){
				//Check if pacman lost a life
				if (game.lostLife == true){
					game.lives--;	
					displayInfo(game.score, game.lives);  

					//Check pacman's available lives
					if (game.lives == 0){
						//Game is Over
						game.gameOver == true;
						game.ignoreKeys = true;
						gameControl.gameOver = true; //global variable
						alert('The game is over');
					}
					else{
						//inform the user
						alert('You have: '+game.lives+' lives remaining!');
						
						//RE INITIALIZE
						//empty keys object
						currentlyPressedKeys = {};

						game.ignoreKeys = true;
						game.lostLife = false;
						game.gameCamera = true;

						if (game.levelNum == 1)
							pacman.init(104);
						else if (game.levelNum == 2)
							pacman.init(255);

						var range = maze.pellets.length;
						var rand = [];

						//Initialize ghosts - Random unique tile generation
						for (var i=0; i<ghosts.length; i++){
							rand[i] = generateRandom(range, 20, rand[0], rand[1], rand[2]);
							ghosts[i].init(maze.pellets[rand[i]].num);
						}
						//alert("Pacman was busted!");
						console.log('pacman busted');
					}
				} else {
					//Check if going to next level	    		
					if (game.levelUp == true){
						game.levelNum++;
		    			//Initialize the maze
						initMaze(level2_design);
		    		} else {
		    			//Check if level complete
		    			console.log()
		   				if (maze.totalPellets == 0){
							game.levelUp = true;
							alert ("Congrats! Loading Next Level!");
						}else{
							game.ignoreKeys = false;
							game.gameOver = false;
							game.lostLife = false;
							determineMove(pacman, game.normalSpeed);

							//Check if in power pellet mode
							if (game.powerMode == true){
								game.gameCamera = false; //set panoramic camera
								game.curGhostSpeed = game.slowGhostSpeed;
								//Check if power mode's time is out
								if (passedTime(game.powerModeDur)){
									regenerateGhosts(game.ghostsBusted); 
									game.powerMode = false;
									game.gameCamera = true; //set tracking camera
									game.curGhostSpeed = game.defGhostSpeed;
								}
							}

							detectCollisions(game.powerMode);
							checkPellets();

							for (var i=0; i<ghosts.length; i++){
								ghosts[i].nextDirection = moveGhosts(ghosts[i]);
								determineMove(ghosts[i], game.curGhostSpeed);
							}

						}
					}


				}
			} else {
				alert('GAME OVER! Sorry...');
				game.ignoreKeys = true;
			}
		}
		var timePoint = 0;
		// Refresh every 'time' ms
		function passedTime(timeMargin){
			if (timePoint == 0){
				timePoint = new Date().getTime();
			}
			var curTime = new Date().getTime();

			if (curTime - timePoint > timeMargin){
				timePoint = 0;
				return true;
			} else 
				return false;
		}

		function checkPellets(){
			//Find current position
			var xPos = pacman.mCenter[0];
			var zPos = pacman.mCenter[1];

			//Get coordinates of current tile
			var i = pacman.curTile.indX;
			var j = pacman.curTile.indZ;

			if (pacman.curDirection == 1){
				//Going up
				var nextTile = maze.level[i+1][j];

				if (nextTile.type !=""){
					if (Math.abs(zPos-nextTile.mCenter[1]) < tileMold.edge/2){
						if (nextTile.type =='U'){
							game.powerMode = true;
						}
						nextTile.type = "";
						maze.totalPellets--;
						game.score += 50;
						displayInfo(game.score, game.lives);
					}
				}
			}else if (pacman.curDirection == 2){
				//Going down
				var nextTile = maze.level[i-1][j];
				if (nextTile.type !=""){
					if (Math.abs(zPos-nextTile.mCenter[1]) < tileMold.edge/2){
						if (nextTile.type =='U'){
							game.powerMode = true;
						}
						nextTile.type = "";
						maze.totalPellets--;
						game.score += 50;
						displayInfo(game.score, game.lives);
					}
				}
			}else if (pacman.curDirection == 10){
				//Goind left
				var nextTile = maze.level[i][j-1];
				if (nextTile.type !=""){
					if (Math.abs(xPos-nextTile.mCenter[0]) < tileMold.edge/2){
						if (nextTile.type =='U'){
							game.powerMode = true;
						}
						nextTile.type = "";
						maze.totalPellets--;
						game.score += 50;
						displayInfo(game.score, game.lives);
					}
				}
			}else if (pacman.curDirection == 20){
				//Goind right
				var nextTile = maze.level[i][j+1];
				if (nextTile.type !=""){
					if (Math.abs(xPos-nextTile.mCenter[0]) < tileMold.edge/2){
						if (nextTile.type =='U'){
							game.powerMode = true;
						}
						nextTile.type = "";
						maze.totalPellets--;
						game.score += 50;
						displayInfo(game.score, game.lives);
					}
				}
			}else if (pacman.curDirection == 0){
				//Stopped
				if (pacman.curTile.type =='p' || pacman.curTile.type =='U'){
					pacman.curTile.type = "";
					maze.totalPellets--;
					game.score += 50;
					displayInfo(game.score, game.lives);
				}
			} 
		}

		function regenerateGhosts(ghostsBusted) {
			//Check if any ghosts were busted
			for (var i=0; i<ghostsBusted.length; i++){
				var tileNum = generateRandom(maze.pellets.length, pacman.curTile, 0, 0, 0);
				ghostsBusted[i].init(maze.pellets[tileNum].num);
			}
			ghostsBusted = [];
		}

		function initMaze(levelDesign) {
			console.log('initMaze');
			//Set the mold for maze tiles
			tileMold.init();
			//Create level
			var level = createLevel(levelDesign);
			//level width
			var width = level[0].length;
			//level height
			var height = level.length;
			//Initialize maze with level
			maze.init(level, height, width);
			//Calculate coordinates and mass center for tiles
			calculateMazeCoords(maze.level, maze.height, maze.width, tileMold.edge, tileMold.zDirection);
			//Initialize possible moves from evey tile
			initLevelMoves(levelDesign, maze.level);
			
			//Create and initialize pacman
			pacman = null;
			pacman = new character("pacman");

			//Create ghosts
			ghosts = [];
			ghosts.push(new character("blinky"));
			ghosts.push(new character("pinky"));
			ghosts.push(new character("inky"));
			ghosts.push(new character("clyde"));

			var range = maze.pellets.length;
			var rand = [];

			//Initialize ghosts - Random unique tile generation
			for (var i=0; i<ghosts.length; i++){
				rand[i] = generateRandom(range, 20, rand[0], rand[1], rand[2]);
				ghosts[i].init(maze.pellets[rand[i]].num);
			}

			//Initialize game
			game.init();

			if (game.levelNum == 1)
				pacman.init(104);
			else if (game.levelNum == 2)
				pacman.init(255); 
		}

		function detectCollisions(powerMode){
			//For circles CHECK 2*r, r=radius
			var distFromGhostX = [];
			var distFromGhostZ = [];

			for (var i=0; i<ghosts.length; i++){

				if ( Math.abs(pacman.curTile.num - ghosts[i].curTile.num) == 1) {
					distFromGhostX[i] = Math.abs(pacman.mCenter[0]-ghosts[i].mCenter[0]);

					if (distFromGhostX[i] < tileMold.edge-maze.speed){
						if (powerMode == true){ //power mode
							displayInfo(game.score, game.lives);
							game.ghostsBusted.push(ghosts[i]);
							ghosts[i].busted = true;

						} else
							game.lostLife = true;
					}

				}else if (Math.abs(pacman.curTile.num - ghosts[i].curTile.num) == maze.width){
					distFromGhostZ[i] = Math.abs(pacman.mCenter[1]-ghosts[i].mCenter[1]);

					if (distFromGhostZ[i] < tileMold.edge-maze.speed){
						if (powerMode == true){//power mode
							displayInfo(game.score, game.lives);
							game.ghostsBusted.push(ghosts[i]);
							ghosts[i].busted = true;

						} else
							game.lostLife = true;
					}
				}
			}
		}

		var pacman = {};
		var ghosts = [];

		function character(name) {
			this.mCenter = [];	//The center of mass
			//Code direction and movement
			//(1) -> moving up, (2) moving down, (10) moving left
			//(20) -> moving right, (0) -> stopped
			this.curDirection = 0;
			this.nextDirection = 0;
			this.scale = 1.0;	//Scale character
			this.curTile = {};	//Reference to the current tile
			this.moveX = 0.0;	//Distance to move on x-axis
			this.moveZ = 0.0;	//Distance to move on z-axis
			this.renderTile = {};	//The tile where pChar will be rendered
			this.name = name;		//character name
			this.busted = false;	//For ghosts is any is busted
			this.pacTarget = -1;		//Target tile for ghost move

			this.updateMove = function(x, z) {
				this.moveX += x//*(-this.scale);	
				this.moveZ += z//*(-this.scale); 
			};

			this.updateCenter = function(x, z) {
				this.mCenter[0] += x//*(this.scale);	
				this.mCenter[1] += z//*(this.scale); 
			};

			//Update the current tile on which the character moves If the center of 
			//mass is edge far
			this.updateCurTile = function(xIndexOffset, zIndexOffset){
				var distFromCurTileX = Math.abs(this.mCenter[0] - this.curTile.mCenter[0]);
				var distFromCurTileZ =  Math.abs(Math.abs(this.mCenter[1]) - Math.abs(this.curTile.mCenter[1]));
				var indX = this.curTile.indX;
				var indZ = this.curTile.indZ;

				//console.log('-> updateNextTile(), Dist from cur: '+distFromCurTileX+', '+distFromCurTileZ);
				if (distFromCurTileX >= tileMold.edge-maze.speed || distFromCurTileZ >= tileMold.edge-maze.speed){
					//Find next tile according to direction
					this.curTile = maze.level[indX + xIndexOffset][indZ + zIndexOffset];
				}
				//console.log('-> updateNextTile(), Updated CURRENT Tile to: '+this.curTile.num);
			};

			//Initialize parameters for character
			this.init = function(tile){
				var j = tile % maze.width;
	    		var i = Math.floor((tile - j) / maze.width);

	    		this.busted = false;

				//Save the reference to the current, next tile and render
				this.curTile = maze.level[i][j];
				this.renderTile = maze.level[i][j];
				//Set center of mass
				this.mCenter[0] = this.curTile.mCenter[0];
				this.mCenter[1] = this.curTile.mCenter[1];

				this.moveX = 0.0;	//Distance to move on x-axis
				this.moveZ = 0.0;	//Distance to move on z-axis

				this.curDirection = 0;
				this.nextDirection = 0;

				this.pacTarget = -1;

				console.log('Init pChar, edge:' + tileMold.edge);
				console.log('Init pChar coords:' + this.mCenter[0] +','+this.mCenter[1]);
			};
		}

		function determineMove(pChar, speed) {
			//console.log('\n');
			//console.log('---> determineMove(), CURRENT: '+pChar.curTile.mCenter[0]+', '+pChar.curTile.mCenter[1]);
			//console.log('---> determineMove(), pChar: '+pChar.mCenter[0]+', '+pChar.mCenter[1]);

			var distFromCurTileX = Math.abs(pChar.mCenter[0] - pChar.curTile.mCenter[0]);
			var distFromCurTileZ =  Math.abs(Math.abs(pChar.mCenter[1]) - Math.abs(pChar.curTile.mCenter[1]));

			var xP = pChar.mCenter[0];
			var zP = pChar.mCenter[1];
			var xM = pChar.curTile.mCenter[0];
			var zM = pChar.curTile.mCenter[1];
			var curDirection = pChar.curDirection;
			var nextDirection = pChar.nextDirection;
			var moveXOffset = speed;
			var moveZOffset = speed;

			//Check if pChar is near to mass center
			if (distFromCurTileX <= maze.speed && distFromCurTileZ <= maze.speed){	
				//console.log('---> determineMove(), CLOSE to center');

				//Check If new direction is allowed (defined)
				if (pChar.curTile.moves[nextDirection] !== undefined) {
					//console.log('---> determineMove(), NEXT direction allowed');

					//Check if new direction is on the same axis
					//Because up->(1), down->(2), left->(10), right->(20)
					if ((curDirection * nextDirection <= 4) || (curDirection * nextDirection >= 100)) {
						//console.log('---> determineMove(), NEXT direction on same-axis');
					} 
					else{
						//console.log('---> determineMove(), NEXT direction on different-axis');
						//If moving up-down
						if (nextDirection == 1 || nextDirection == 2){
							//Move on x-axis to center of mass
							moveXOffset = distFromCurTileX;//Math.abs(pChar.mCenter[0] - pChar.curTile.mCenter[0]);
							//console.log('---> determineMove(), CUR TILE CENTER: '+pChar.curTile.mCenter[0]+', '+pChar.curTile.mCenter[1]);
						} else if (nextDirection == 10 || nextDirection == 20) {
						//If moving Left-Right
							//Move on x-axis to center of mass
							//console.log('---> determineMove(), CUR TILE CENTER: '+pChar.curTile.mCenter[0]+', '+pChar.curTile.mCenter[1]);
							moveZOffset = distFromCurTileZ; //Math.abs(pChar.mCenter[1] - pChar.curTile.mCenter[1]);
						}
					}
				} else {
					//Check if current direction is valid
					if (pChar.curTile.moves[curDirection] !== undefined) {
						//Keep current direction
						//console.log('---> determineMove(), NEXT direction NOT allowed, following CURRENT');
						pChar.nextDirection = curDirection;
					} else {
						//console.log('---> determineMove(), STOP');
						//STOP
						//console.log('---> determineMove(), Cur tile center: '+pChar.curTile.mCenter[0]+', '+pChar.curTile.mCenter[1]);
						moveXOffset = Math.abs(pChar.mCenter[0] - pChar.curTile.mCenter[0]);
						moveZOffset = Math.abs(pChar.mCenter[1] - pChar.curTile.mCenter[1]);
						pChar.nextDirection = 0;
					} 
				}
			} else {
				//Check if new direction is not on the same axis
				//Because up->(1), down->(2), left->(10), right->(20)
				if ((curDirection * nextDirection <= 4) || (curDirection * nextDirection >= 100)){
					//console.log('---> determineMove(), SAME AXIS direction');
				} else {
					//console.log('---> determineMove(), NEW AXIS direction');
					//New direction is on another axis so keep current
					pChar.nextDirection = curDirection;
					
				}
			}
			//console.log('---> determineMove(), pChar: '+pChar.mCenter[0]+', '+pChar.mCenter[1]);
			move(pChar, moveXOffset, moveZOffset);
		}

		function move(pChar, offsetX, offsetZ){
			//Move Up
			if (pChar.nextDirection == 1){
				//console.log('--> move(), move Up');
				//Update center of mass coordinates
				pChar.updateCenter(0, offsetZ*tileMold.zDirection);
				//console.log('--> move(), pChar updated: '+pChar.mCenter[0]+', '+pChar.mCenter[1]);
				//Set distance to move pChar
				pChar.updateMove(0, offsetZ);
				//Update current tile
				pChar.updateCurTile(1, 0);
			} else if (pChar.nextDirection == 2){
				//console.log('--> move(), move Down');
			//Move down
				//Update center of mass coordinates
				pChar.updateCenter(0, -offsetZ*tileMold.zDirection);
				//Set distance to move pChar
				pChar.updateMove(0, -offsetZ);
				//Update current tile
				pChar.updateCurTile(-1, 0);
			} else if (pChar.nextDirection == 10){
				//console.log('--> move(), move Left');
			//Move left
				//Update center of mass coordinates
				pChar.updateCenter(-offsetX, 0);
				//Set distance to move pChar
				pChar.updateMove(-offsetX, 0);
				//Update current tile
				pChar.updateCurTile(0, -1);
			} else if (pChar.nextDirection == 20){
				//console.log('--> move(), move Right');
			//Move right
				//Update center of mass coordinates
				pChar.updateCenter(offsetX, 0);
				//Set distance to move pChar
				pChar.updateMove(offsetX, 0);
			//Update current tile
				pChar.updateCurTile(0, 1);
			} else if (pChar.nextDirection == 0){
				//console.log('--> move(), Stop');
			//Stopped
				//Move 0
				pChar.updateMove(0, 0);
			}

			pChar.curDirection = pChar.nextDirection;
			//Update the current tile
			//pChar.updateCurTiles);
		}

		function renderCharacter(pChar){
			var j = pChar.renderTile.indX;
	    	var i = pChar.renderTile.indZ;

			mvPushMatrix();
			mat4.translate(mvMatrix, [i*tileMold.edge, tileMold.transY, j*tileMold.edge*tileMold.zDirection]);
			mat4.scale(mvMatrix, [tileMold.scaleX, tileMold.scaleY, tileMold.scaleZ]);
			mat4.translate(mvMatrix, [pChar.moveX, 1.5, pChar.moveZ*tileMold.zDirection]);
	     	//a rotation connected with animation parameters
	        //mat4.rotate(mvMatrix, degToRad(rCube), [0, 1, 0]);
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
			//console.log('----> draw(), pChar moveX: '+ pChar.moveX+', moveZ: '+pChar.moveZ);
		}

	    function drawScene() {
	    	//the viewport gets the canvas values (that were assigned to the gl context variable)
       		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			//Clear <canvas>
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			//set uniform matrices before draw
			setMatrixUniforms();

			//Render pChars
			drawCustomColor = 1;
			renderCharacter(pacman);

			for (var i=0; i<ghosts.length; i++){
				//if the ghost is not busted render it 
				if (ghosts[i].busted == false) {
					//Check power mode
					if (game.powerMode != true){
						if (ghosts[i].name == "blinky")
							drawCustomColor = 2;
						else if (ghosts[i].name == "pinky")
							drawCustomColor = 3;
						else if (ghosts[i].name == "inky")
							drawCustomColor = 4;
						else if (ghosts[i].name == "clyde")
							drawCustomColor = 5;
					}else
						drawCustomColor = 6;

					renderCharacter(ghosts[i]);
				}
			}

			drawCustomColor = 0; //de-activate custom color-mode
			//Instantiation of the maze
			for (var i = 0; i < maze.height; i++){
				for (var j = 0; j < maze.width; j++){
					if (maze.level[i][j].type == 'x') {
						mvPushMatrix();
						mat4.translate(mvMatrix, [j*tileMold.edge, tileMold.transY, i*tileMold.edge*tileMold.zDirection]);
						mat4.scale(mvMatrix, [tileMold.scaleX, tileMold.scaleY, tileMold.scaleZ]);
						setMatrixUniforms();
						gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
						mvPopMatrix();
					}else if (maze.level[i][j].type == 'p'){
						pelletScale = 0.9;
						up = tileMold.edge/6;
						mvPushMatrix();
						mat4.translate(mvMatrix, [j*tileMold.edge, tileMold.transY+up, i*tileMold.edge*tileMold.zDirection]);
						mat4.scale(mvMatrix, [tileMold.scaleX-pelletScale, tileMold.scaleX-pelletScale, tileMold.scaleZ-pelletScale]);
						setMatrixUniforms();
						gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
						mvPopMatrix();
					} else if (maze.level[i][j].type == 'U'){
						pelletScale = 0.75;
						up = tileMold.edge/6;
						mvPushMatrix();
						//mat4.rotate(mvMatrix, degToRad(20), [1, 0, 0]);	//pitch -> tils
						mat4.translate(mvMatrix, [j*tileMold.edge, tileMold.transY+up, i*tileMold.edge*tileMold.zDirection]);
						mat4.scale(mvMatrix, [tileMold.scaleX-pelletScale, tileMold.scaleX-pelletScale, tileMold.scaleZ-pelletScale]);
						setMatrixUniforms();
						gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
						mvPopMatrix();
					}
				}
			}	
	    }

		function generateRandom(range, num1, num2, num3, num4) {
		    var num = Math.floor(Math.random() * (range));
		    return (num === num1 || num === num2 || num === num3 || num === num4) ? generateRandom(range) : num;
		}

	    function calculateMazeCoords(tilesArray, height, width, edge, zDirection){
	    //Calculate the coordinates and the center of mass
	    //of every tile of the maze
    		//V0 [-1.0, 1.0]
    		//V1 [ 1.0, 1.0]
    		//V2 [ 1.0,-1.0]
    		//V3 [-1.0,-1.0] 
	    	var initZ = 1.0;
	    	var initX = -1.0;
	    	var mCenter = [0, 0];

			for (var i = 0; i < height; i++){
				var newZ = initZ + edge * zDirection * i;
				var nextNewZ = initZ + edge * zDirection * (i+1.0);

				for (var j = 0; j < width; j++){
					var newX = initX + edge * j;
					var nextNewX = initX + edge * (j+1.0);
					//Set coordinates
					tilesArray[i][j].vertices[0] = [newX, newZ];
					tilesArray[i][j].vertices[1] = [nextNewX, newZ];
					tilesArray[i][j].vertices[2] = [nextNewX, nextNewZ];
					tilesArray[i][j].vertices[3] = [newX, nextNewZ];
					//Set center of mass
					tilesArray[i][j].mCenter[0] = (newX + nextNewX)/2;
					tilesArray[i][j].mCenter[1] = (newZ + nextNewZ)/2;
				}
	    	}
	    }

		function panoramicCamera(){
	    	//the projection matrix (pMatrix) is set
			//45 degrees Field-Of-View
			//aspect ratio gl.viewportWidth / gl.viewportHeight
			//near plane: 0.1 , far plane: 100
			mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		
			//the modelview Matrix is initialized with the Identity Matrix
			mat4.identity(mvMatrix);	

			var pitch = 90;
			var yOffset = -20;


			if (pacman.curDirection == 1 || pacman.curDirection == 2){				
				mat4.rotate(mvMatrix, degToRad(pitch), [1, 0, 0]);	//pitch -> tilt
				mat4.translate(mvMatrix, [-pacman.renderTile.mCenter[0] - pacman.moveX, yOffset, -pacman.renderTile.mCenter[1] + pacman.moveZ]); 

			} else if (pacman.curDirection == 10 || pacman.curDirection == 20){				
				mat4.rotate(mvMatrix, degToRad(pitch), [1, 0, 0]);	//pitch -> tilt
				mat4.translate(mvMatrix, [-pacman.renderTile.mCenter[0] - pacman.moveX, yOffset, -pacman.renderTile.mCenter[1] + pacman.moveZ]); 

			} else{				
				mat4.rotate(mvMatrix, degToRad(pitch), [1, 0, 0]);	//pitch -> tilt
				mat4.translate(mvMatrix, [-pacman.renderTile.mCenter[0] - pacman.moveX, yOffset, -pacman.renderTile.mCenter[1] + pacman.moveZ]);
			}
		}

	    function trackingCamera(){
	    	var modelMatrix = mat4.create(); //Model matrix
	    	//the projection matrix (pMatrix) is set
			//45 degrees Field-Of-View
			//aspect ratio gl.viewportWidth / gl.viewportHeight
			//near plane: 0.1 , far plane: 100
			//mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		
			//the modelview Matrix is initialized with the Identity Matrix
			mat4.identity(mvMatrix);	


			var pitch = 20;
			var yaw = 45;
			var offset = 3.0;


			if (game.levelNum == 1){
			//At level-1 load this camera
				mat4.rotate(mvMatrix, degToRad(pitch), [1, 0, 0]);	//pitch -> tilt
				mat4.rotate(mvMatrix, degToRad(yaw), [0, 1, 0]);	//yaw	 -> angle
				mat4.translate(mvMatrix, [-pacman.moveX-tileMold.edge*maze.width/6, -offset, pacman.moveZ]); 
			}
			else if (game.levelNum == 2){
			//At level-2 load this camera
				mat4.rotate(mvMatrix, degToRad(pitch), [1, 0, 0]);	//pitch -> tilt
				mat4.rotate(mvMatrix, degToRad(yaw), [0, 1, 0]);	//yaw	 -> angle
				mat4.translate(mvMatrix, [-pacman.mCenter[0]+10, -offset, -pacman.mCenter[1]-10]);
			}

			mat4.inverse(mvMatrix, normalMatrix);
			mat4.transpose(normalMatrix, normalMatrix);
			mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

	    }

	    function setGameCamera(){
	    	//Set tha camera for the game.
	    	//True -> tracking camera
	    	//False -> Panoramic camera
	    	if (game.gameCamera == true){
	    		trackingCamera();
	    	}else{
	    		panoramicCamera();
	    	}
	    }

    	//animation parameter
	    var lastTime = 0;
		var counter = 0.0;

		//Animate function
	    function animate() {
	        var timeNow = new Date().getTime();
	        if (lastTime != 0) {
	            var elapsed = timeNow - lastTime;

				//adjust a constant rotation speed independently of platform/framerate
	            rCube -= (75 * elapsed) / 1000.0;
				
				counter += elapsed;
				if (counter > 1000.0){
					movDirection = !movDirection;
					counter = 0;
					}
				if (movDirection)
					swinging += (1 * elapsed) / 1000.0;
				else 
					swinging -= (1 * elapsed) / 1000.0;
					
				
	        }
	        lastTime = timeNow;
	    }


	    var gameControl = {
	    	gameOver: false,
	    }


		//this is the requestAnimFrame callback
		//For every tick, request another frame
		//handle keyboard, draw the scene, animate (update animation variebles) and continue
	    function tick() {
	    	if (gameControl.gameOver == false){
	    		requestAnimFrame(tick);
				handleKeys();
				//Set game camera
				setGameCamera();
		        drawScene();
				checkGameplay();
		        //animate();	
	    	}
    	}


		//Entry point of the WebGL context
		function webGLStart() {
			//global
	        canvas = document.getElementById("MyWebGl");
			//Functions for initialization
			//Check above
			initGL(canvas);
	        initShaders();
	        initBuffers();

			//Initialize the maze
			initMaze(level1_design);

			//Background Color: Color assigned for all pixels with no corresponding fragments
	        gl.clearColor(0.0, 0.0, 0.0, 1.0);
			
			//Enable z-buffer for depth sorting
	        gl.enable(gl.DEPTH_TEST);

			//define the keyboard handlers
			document.onkeydown = handleKeyDown;
	        document.onkeyup = handleKeyUp;
			//the first tick of our application
			tick();
	    }

	    function displayInfo(score, lives){
	    	var theScore ="Pacman score: "+ score;
	    	var nl = "</br>";
	    	var theLives = "Lives: "+lives;

	    	document.getElementById("h1").innerHTML = theScore + nl + theLives;
	    }


	</script>




	<!--CSS to center the Canvas element !-->
	<style>
		#MyWebGl{	
    		display: block;
    		margin: 0 auto;
		}

		#h1{	
			font-family: "Arial";
    		text-align: center;
    		font-size: 30px;
    		letter-spacing: -1px; 
    		font-weight: bold; 
		}

		#info{
			text-align: center;
			font-family: "Arial";
			font-size: 20px;
			font-weight: bold; 
			font-color: red;
		}

		#header{
			text-align: center;
			font-family: "Sans-serif";
		}

		hr { 
		    display: block;
		    margin-top: 0.5em;
		    margin-bottom: 0.5em;
		    margin-left: auto;
		    margin-right: auto;
		    border-style: inset;
		    border-width: 1px;
		} 


	</style>


	</head>

	<body>
		<div id="header">
			<h1>Pacmaze</h1>
			<p><em>by</em> <strong>Lappas Dionysis</strong></p>
			<hr>
			<p>
				This is a pacman-like 3d game based exclusively on <strong>Web technologies</strong>: WegGl, Javascript and Html. Code on <a href="https://github.com/denlap007/pacmaze" target="blank">Github repo</a> too.
				</br>
				</br>
				Change game camera with 'P' (Panoramic) and 'T' (Tracking) keyboard keys.
				</br>
				</br>
				<!-- calls the entry point of our application -->
			</p>
			<button type="button" onclick="this.disabled=true; webGLStart();">Start Game</button>
			</br>
			</br>
		</div>
		<!-- HMTL for the canvas element-->
		<canvas id="MyWebGl" style="border: none;" width="800" height="500"></canvas>
		<div id="h1"></div>
		<p id="info"></p>
	</body>

</html>